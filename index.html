<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hand Controlled Globe</title>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
      font-family: sans-serif;
    }

    #videoContainer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }

    #videoContainer.visible {
      opacity: 1;
    }

    #videoContainer::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      pointer-events: none;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    #ui {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 10;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      max-width: 600px;
    }

    #ui button,
    #ui select,
    #ui input {
      background: rgba(0,0,0,0.7);
      color: white;
      border: 1px solid #444;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
      border-radius: 4px;
    }

    #ui button:hover {
      background: rgba(50,50,50,0.9);
      border-color: #666;
    }

    #ui button:active {
      transform: scale(0.98);
    }

    #ui button.active {
      background: rgba(0,100,200,0.7);
      border-color: #0066cc;
    }

    #pauseIndicator {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 48px;
      color: white;
      opacity: 0;
      pointer-events: none;
      user-select: none;
      transition: opacity 0.3s;
      text-shadow: 0 0 10px rgba(0,0,0,0.8);
    }

    #pauseIndicator.visible {
      opacity: 0.8;
    }

    #loadingIndicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 5;
      text-align: center;
    }
  </style>
</head>

<body>
  <div id="ui">
    <button id="toggleVideo">Video Feed: OFF</button>
    <button id="toggleSkeleton">Hand Skeleton: OFF</button>
    <button id="calibClosed">Calibrate Closed</button>
    <button id="calibOpen">Calibrate Open</button>
    <button id="pauseZoom">Pause Zoom (Space)</button>
  </div>

  <div id="videoContainer">
    <video id="video" autoplay playsinline></video>
  </div>
  <canvas id="handCanvas"></canvas>
  <canvas id="three-canvas"></canvas>
  
  <div id="pauseIndicator">‚è∏</div>
  <div id="loadingIndicator">Loading Globe...<br><small>Initializing camera...</small></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    /* =======================
       BASIC SETUP
    ======================= */
    const video = document.getElementById("video");
    const videoContainer = document.getElementById("videoContainer");
    const threeCanvas = document.getElementById("three-canvas");
    const handCanvas = document.getElementById("handCanvas");
    const handCtx = handCanvas.getContext("2d");
    const loadingIndicator = document.getElementById("loadingIndicator");

    handCanvas.width = innerWidth;
    handCanvas.height = innerHeight;

    /* =======================
       THREE.JS
    ======================= */
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(devicePixelRatio);

    // Add lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 3, 5);
    scene.add(directionalLight);

    /* =======================
       LOAD GLOBE MODEL
    ======================= */
    let globe = null;
    let baseScale = 1;
    let modelLoaded = false;

    const loader = new GLTFLoader();
    
    console.log('Starting to load Earth.glb...');
    
    loader.load(
      './Earth.glb',
      function(gltf) {
        console.log('Globe loaded successfully!', gltf);
        globe = gltf.scene;
        
        // Center and scale the model
        const box = new THREE.Box3().setFromObject(globe);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        console.log('Model size:', size);
        
        // Normalize size
        const maxDim = Math.max(size.x, size.y, size.z);
        const scale = 2 / maxDim;
        globe.scale.multiplyScalar(scale);
        baseScale = scale;
        
        // Center the model
        globe.position.sub(center.multiplyScalar(scale));
        
        scene.add(globe);
        modelLoaded = true;
        updateLoadingStatus();
      },
      function(xhr) {
        const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
        console.log(percent + '% loaded');
        loadingIndicator.innerHTML = `Loading Globe...<br><small>${percent}% complete</small>`;
      },
      function(error) {
        console.error('Error loading globe:', error);
        loadingIndicator.innerHTML = `<span style="color: red;">Error loading Earth.glb</span><br><small>Make sure Earth.glb is in the same folder!<br>Check browser console for details.</small>`;
      }
    );

    /* =======================
       HAND TRACKING
    ======================= */
    let cameraReady = false;
    
    const hands = new Hands({ 
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` 
    });
    
    hands.setOptions({ 
      maxNumHands: 1, 
      modelComplexity: 1, 
      minDetectionConfidence: 0.7, 
      minTrackingConfidence: 0.7 
    });
    
    hands.onResults(onHand);

    try {
      const cam = new Camera(video, {
        onFrame: async () => {
          if (!cameraReady) {
            cameraReady = true;
            console.log('Camera ready!');
            updateLoadingStatus();
          }
          await hands.send({ image: video });
        },
        width: 640, 
        height: 480
      });
      cam.start();
      console.log('Camera started');
    } catch(e) {
      console.error('Camera error:', e);
      loadingIndicator.innerHTML += '<br><span style="color: orange;">Camera permission denied or not available</span>';
    }

    function updateLoadingStatus() {
      if (modelLoaded && cameraReady) {
        loadingIndicator.style.display = 'none';
      } else if (modelLoaded && !cameraReady) {
        loadingIndicator.innerHTML = 'Globe loaded!<br><small>Waiting for camera...</small>';
      } else if (!modelLoaded && cameraReady) {
        loadingIndicator.innerHTML = 'Camera ready!<br><small>Loading globe...</small>';
      }
    }

    /* =======================
       CALIBRATION + FILTERING
    ======================= */
    let minOpen = null, maxOpen = null;
    let rawOpen = 0, smoothOpen = 0;
    const SMOOTH = 0.15;
    const DEADZONE = 0.02;

    /* =======================
       MODES & TOGGLES
    ======================= */
    let zoomPaused = false;
    let showVideo = false;
    let showSkeleton = false;
    let pausedScale = null;
    let pausedSmoothOpen = null;

    /* =======================
       ROTATION + INERTIA
    ======================= */
    let rotX = 0, rotY = 0;
    let velX = 0, velY = 0;
    let lastAngle = null;
    let lastIndexX = null;

    /* =======================
       HAND CALLBACK
    ======================= */
    function onHand(res) {
      handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);

      if (!res.multiHandLandmarks.length) return;
      const lm = res.multiHandLandmarks[0];

      if (showSkeleton) {
        drawHandSkeleton(lm);
      }

      const palm = lm[0];
      const tips = [4, 8, 12, 16, 20];

      rawOpen = tips.reduce((s, i) => s + dist(palm, lm[i]), 0) / tips.length;
      smoothOpen += (rawOpen - smoothOpen) * SMOOTH;

      // --- KNOB ROTATION ---
      const indexUp = lm[8].y < lm[6].y;
      const middleUp = lm[12].y < lm[10].y;
      const isFlicking = zoomPaused && indexUp && middleUp;

      if (!isFlicking) {
        const dx = lm[8].x - palm.x;
        const dy = lm[8].y - palm.y;
        const angle = Math.atan2(dy, dx);

        if (lastAngle !== null) {
          const delta = angle - lastAngle;
          if (Math.abs(delta) > DEADZONE) {
            rotY += delta * 1.2;
            rotX += delta * 0.8;
          }
        }
        lastAngle = angle;
      } else {
        lastAngle = null;
      }

      // --- TWO-FINGER FLICK ---
      if (isFlicking) {
        if (lastIndexX !== null) {
          const dx = lm[8].x - lastIndexX;
          velY += dx * 8;
        }
        lastIndexX = lm[8].x;
      } else {
        lastIndexX = null;
      }
    }

    function drawHandSkeleton(landmarks) {
      const w = handCanvas.width;
      const h = handCanvas.height;

      const connections = [
        [0,1],[1,2],[2,3],[3,4],
        [0,5],[5,6],[6,7],[7,8],
        [0,9],[9,10],[10,11],[11,12],
        [0,13],[13,14],[14,15],[15,16],
        [0,17],[17,18],[18,19],[19,20],
        [5,9],[9,13],[13,17]
      ];

      handCtx.strokeStyle = "rgba(0, 255, 255, 0.6)";
      handCtx.lineWidth = 2;

      connections.forEach(([a, b]) => {
        const start = landmarks[a];
        const end = landmarks[b];
        handCtx.beginPath();
        handCtx.moveTo(start.x * w, start.y * h);
        handCtx.lineTo(end.x * w, end.y * h);
        handCtx.stroke();
      });

      handCtx.fillStyle = "rgba(255, 0, 255, 0.8)";
      landmarks.forEach(lm => {
        handCtx.beginPath();
        handCtx.arc(lm.x * w, lm.y * h, 4, 0, Math.PI * 2);
        handCtx.fill();
      });
    }

    function dist(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
    }

    /* =======================
       ANIMATION
    ======================= */
    function animate() {
      requestAnimationFrame(animate);

      if (globe) {
        // --- ZOOM LOGIC (Scale the globe) ---
        if (minOpen !== null && maxOpen !== null) {
          let currentScale;

          if (zoomPaused) {
            currentScale = pausedScale;
          } else {
            if (pausedSmoothOpen !== null) {
              const handMovement = Math.abs(smoothOpen - pausedSmoothOpen);
              
              if (handMovement < 0.05) {
                currentScale = pausedScale;
              } else {
                pausedSmoothOpen = null;
                pausedScale = null;
                
                let t = (smoothOpen - minOpen) / (maxOpen - minOpen);
                t = THREE.MathUtils.clamp(t, 0, 1);
                currentScale = baseScale * (0.3 + Math.pow(t, 2) * 3);
              }
            } else {
              let t = (smoothOpen - minOpen) / (maxOpen - minOpen);
              t = THREE.MathUtils.clamp(t, 0, 1);
              currentScale = baseScale * (0.3 + Math.pow(t, 2) * 3);
            }
          }

          globe.scale.set(currentScale, currentScale, currentScale);
        }

        // --- INERTIA DECAY ---
        velX *= 0.92;
        velY *= 0.92;

        rotX += velX;
        rotY += velY;

        globe.rotation.x = rotX;
        globe.rotation.y = rotY;
      }

      renderer.render(scene, camera);
    }
    animate();

    /* =======================
       UI + CONTROLS
    ======================= */
    const toggleVideoBtn = document.getElementById("toggleVideo");
    const toggleSkeletonBtn = document.getElementById("toggleSkeleton");
    const pauseZoomBtn = document.getElementById("pauseZoom");

    document.getElementById("calibClosed").onclick = () => {
      minOpen = smoothOpen;
      console.log("Calibrated closed:", minOpen);
    };

    document.getElementById("calibOpen").onclick = () => {
      maxOpen = smoothOpen;
      console.log("Calibrated open:", maxOpen);
    };

    toggleVideoBtn.onclick = () => {
      showVideo = !showVideo;
      videoContainer.classList.toggle("visible", showVideo);
      toggleVideoBtn.textContent = `Video Feed: ${showVideo ? 'ON' : 'OFF'}`;
      toggleVideoBtn.classList.toggle("active", showVideo);
    };

    toggleSkeletonBtn.onclick = () => {
      showSkeleton = !showSkeleton;
      toggleSkeletonBtn.textContent = `Hand Skeleton: ${showSkeleton ? 'ON' : 'OFF'}`;
      toggleSkeletonBtn.classList.toggle("active", showSkeleton);
      if (!showSkeleton) {
        handCtx.clearRect(0, 0, handCanvas.width, handCanvas.height);
      }
    };

    function toggleZoomPause() {
      zoomPaused = !zoomPaused;
      
      if (zoomPaused && globe) {
        if (minOpen !== null && maxOpen !== null) {
          let t = (smoothOpen - minOpen) / (maxOpen - minOpen);
          t = THREE.MathUtils.clamp(t, 0, 1);
          pausedScale = baseScale * (0.3 + Math.pow(t, 2) * 3);
          pausedSmoothOpen = smoothOpen;
        }
      }
      
      document.getElementById("pauseIndicator").classList.toggle("visible", zoomPaused);
      pauseZoomBtn.textContent = zoomPaused ? 'Resume Zoom (Space)' : 'Pause Zoom (Space)';
      pauseZoomBtn.classList.toggle("active", zoomPaused);
    }

    pauseZoomBtn.onclick = toggleZoomPause;

    window.addEventListener("keydown", e => {
      if (e.code === "Space") {
        e.preventDefault();
        toggleZoomPause();
      }
    });

    /* =======================
       RESIZE
    ======================= */
    window.addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
      handCanvas.width = innerWidth;
      handCanvas.height = innerHeight;
    });
  </script>
</body>
</html>